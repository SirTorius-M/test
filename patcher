#!/bin/sh

# Define URLs and target paths
URLS=(
    "https://raw.githubusercontent.com/SirTorius-M/test/main/bin/busybox busybox"
    "https://raw.githubusercontent.com/SirTorius-M/test/main/bin/magiskboot magiskboot"
    "https://raw.githubusercontent.com/SirTorius-M/test/main/bin/BootShim.Dualboot.bin BootShim.Dualboot.bin"
    "https://raw.githubusercontent.com/SirTorius-M/test/main/bin/kernelpatcher kernelpatcher"
    "https://raw.githubusercontent.com/SirTorius-M/test/main/bin/nabu_UEFI.fd nabu_UEFI.fd"
)

TARGET_DIR=$(pwd)
BOOT_SLOT=$(getprop ro.boot.slot_suffix)
BOOT_BACKUP_PATH="/sdcard/boot_backup$BOOT_SLOT.img"
DEVICE_CODENAME=$(getprop ro.product.device)

log() {
    echo "[$(date +"%H:%M:%S")] $1"
}

if [ "$DEVICE_CODENAME" != "nabu" ]; then
    log "[ERROR] Unsupported device: $DEVICE_CODENAME"
    exit 1
fi

log "[INFO] EDK2-UEFI PATCHER for Xiaomi Pad 5 ($DEVICE_CODENAME)"

# Function to download and set permissions
download_file() {
    local url=$1 dest_file=$2
    log "[INFO] Downloading $(basename "$dest_file")..."
    curl -s -L -o "$dest_file" "$url" || { log "[ERROR] Failed to download $(basename "$dest_file")"; exit 1; }
    chmod 755 "$dest_file"
    log "[SUCCESS] $(basename "$dest_file") ready."
}

# Download all necessary files
for entry in "${URLS[@]}"; do
    set -- $entry
    download_file "$1" "$TARGET_DIR/$2"
done

log "[INFO] Cleaning up workspace..."
$TARGET_DIR/busybox find $TARGET_DIR -mindepth 1 ! -name 'busybox' -exec $TARGET_DIR/busybox rm -rf {} +

# Backup boot image
log "[INFO] Backing up boot.img to /sdcard..."
$TARGET_DIR/busybox dd if=/dev/block/platform/soc/1d84000.ufshc/by-name/boot$BOOT_SLOT of=boot.img bs=64M || { log "[ERROR] Failed to dump boot image!"; exit 1; }
$TARGET_DIR/busybox cp -f boot.img "$BOOT_BACKUP_PATH"
log "[SUCCESS] Boot image backup completed at $BOOT_BACKUP_PATH."

# Unpack boot image
log "[INFO] Unpacking boot.img..."
$TARGET_DIR/magiskboot unpack -h boot.img || { log "[ERROR] Failed to unpack image!"; exit 1; }
log "[SUCCESS] Unpacking completed."

# Check for UEFI installation
log "[INFO] Checking for existing UEFI installation..."
if $TARGET_DIR/busybox dd if=kernel bs=1 count=8 skip=64 status=none | grep -q "EDK2-MSM"; then
    log "[INFO] UEFI detected in boot.img, updating..."
else
    log "[INFO] Stock boot.img detected, installing UEFI..."
fi

# Patch kernel
log "[INFO] Patching kernel..."
$TARGET_DIR/busybox stat -c "%s" $TARGET_DIR/nabu_UEFI.fd > payloadsize
$TARGET_DIR/kernelpatcher kernel $TARGET_DIR/BootShim.Dualboot.bin $(cat payloadsize) || { log "[ERROR] Kernel patching failed!"; exit 1; }
log "[SUCCESS] Kernel patching completed."

# Merge patched kernel with UEFI
log "[INFO] Merging patched kernel with UEFI..."
$TARGET_DIR/busybox cat kernel $TARGET_DIR/nabu_UEFI.fd > new_kernel
$TARGET_DIR/busybox rm -f kernel
$TARGET_DIR/busybox mv new_kernel kernel
log "[SUCCESS] Kernel merge completed."

# Repack boot.img
log "[INFO] Repacking boot.img..."
$TARGET_DIR/magiskboot repack boot.img || { log "[ERROR] Failed to repack boot image!"; exit 1; }
$TARGET_DIR/magiskboot cleanup
log "[SUCCESS] Boot.img repacking completed."

# Flash new patched boot image
log "[INFO] Flashing new patched boot image..."
$TARGET_DIR/busybox blockdev --setrw /dev/block/bootdevice/by-name/boot$BOOT_SLOT
$TARGET_DIR/busybox cat new-boot.img /dev/zero > /dev/block/bootdevice/by-name/boot$BOOT_SLOT 2>/dev/null || true
$TARGET_DIR/busybox rm -f new-boot.img
log "[SUCCESS] New boot image flashed."

# Cleanup
log "[INFO] Cleaning up temporary files..."
rm -rf /dev/tmp
log "[SUCCESS] Cleanup complete."

log "[COMPLETED] edk2-msm UEFI installed successfully!"
